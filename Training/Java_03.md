### 三項演算子
​
まずはif文のおさらいをしていきます。  
三項演算子は簡単に説明するとif文を簡略化したものなのでif文とどう違うのか見比べていきましょう。
​
```java
// if文①
int age = 20;
String result = "";
if (age >= 20) {
    result = "20歳以上です";
} else {
    result = "20歳未満です";
}
System.out.println(result);
​
// if文②
String gender = "redy";
if (gender.equals("boy")) {
    result = "男の子です";
} else {
    result = "女の子です";
}
System.out.println(result);
​
// if文③
boolean japan = true;
if (japan) {
    result = "日本人です";
} else {
    result = "日本人ではありません";
}
System.out.println(result);
```
​
①では`age`が`20以上`であれば「`20以上です`」、そうでなければ「`20未満です`」を出力します。  
②では`gender`が`boy`であれば「`男の子です`」、そうでなければ「`女の子です`」を出力します。  
③では`japan`が`true`であれば「`日本人です`」、`false`であれば「`日本人ではありません`」を出力します。  
  
​
上の３つのif文を三項演算子にしてみます。      
​
```java
// 三項演算子①
int age = 20;
System.out.println(age >= 20 ? "20歳以上です" : "20歳未満です");
​
// 三項演算子②
String gender = "redy";
System.out.println(gender.equals("boy") ? "男の子です" : "女の子です");
​
// 三項演算子③
boolean japan = true;
System.out.println(japan == "boy" ? "日本人です" : "日本人ではありません");
```
①を例に挙げて解説すると`age >= 20 ?`がif文の`if (age >= 20)`の役割をしています。  
また、`age`が`20以上`だった場合は`20歳以上です`を出力し、`0～19`の場合は`20歳未満です`を出力しています。`:`はif文の`else`の役割をしています。
​
三項演算子にするとかなり簡単で見やすくなりました。  
if文では何行も書かなければいけなかった文が三項演算子では1行になっています。
​
①～③の問題は単純なif文を三項演算子にした場合です。  
次に複雑なif文を三項演算子に直していきます。  
​
```java
// if文
String drink = "";
if (drink.equals("お茶")) {
  System.out.println("これはお茶です");
} else if (drink.equals("コーヒー")) {
  System.out.println("これはコーヒーです");
} else if (drink.equals("ジュース")) {
  System.out.println("これはジュースです");
} else {
  System.out.println("これは飲み物です");
}
```
​
`drink`が`お茶`であれば`これはお茶です`を出力し、そうでない場合`drink`が`コーヒー`であれば`これはコーヒーです`を出力、  
`お茶`でも`コーヒー`でもなく`ジュース`だった場合は`これはジュースです`を出力、それ以外の場合は`これは飲み物です`を出力しています。  
​
このif文を三項演算子にしてみます。
​
```java
// 三項演算子
String drink = "お茶";
System.out.println(
    drink.equals("お茶") ? "これはお茶です" : 
    drink.equals("コーヒー") ? "これはコーヒーです" : 
    drink.equals("ジュース") ? "これはジュースです" : 
    "これは飲み物です"
);
``` 

複雑なif文は三項演算子にすると逆に分かりにくくなってしまう場合があります。
見間違いなどを防ぐためにも、上記のような条件がいくつもある場合は三項演算子は利用せずif文を使いましょう。  

---
## 配列
​
テストでAさん、Bさん、Cさん、Dさん、Eさんの５人の点数を管理するプログラムを作りたいとします。
​
まずは、AさんからEさんの点数を入れるための変数を用意します。
​
```java
int scoreA;
int scoreB;
int scoreC;
int scoreD;
int scoreE;
```
​
同じような変数型を何度も書くのは面倒くさいです。下記のようにまとめて書くことも可能です。
​
```java
int scoreA, scoreB, scoreC, scoreD, scoreE;
```
​
でもやっぱり、同じような目的の変数をいくつも用意するのは面倒です。
そんな時は配列を使うと便利です。  
基本的に同じ意味(使い方)をしている変数のみを配列にします。  
異なる意味(年齢、身長、体重とか)は同じint型の変数でも同じ配列にまとめてしまうとバグの原因になります。
​
### 配列の宣言と初期化
​
`scoreA`から`scoreE`までのintの宣言文をやめて、配列を使うために配列の宣言を書きます。
変数名は、`score`が複数あるので`scores`とします。
​
```java
int[] scores;
```
​
型の宣言の後ろに`[]`を書くことで、型の配列ができます。今回は`int[]`でint型の配列を作成しました。
​
次にint型の配列変数を初期化します。
​
```java
int[] scores;
scores = new int[5];
```
​
`new`についてですが、クラスやオブジェクトやインスタンスなど大事な要素ですが、現時点ではプログラムで便利な機能を使う事ができる道具として使用していきます。  
`new int[5]`で、５つの要素を持ったint型の配列の機能を持った道具を作って、道具を`scores`変数に代入しています。
初期化を行った時点で、各要素には全て`0`の値が入っています。
​
他の変数と同様に変数型の宣言と初期化を同時にできます。
​
```java
int[] scores = new int[5];
```
​
### 配列の各要素に値を代入
​
配列の各要素に今回の点数を代入してみましょう。
​
```java
int[] scores = new int[5];
​
scores[0] = 90;
scores[1] = 45;
scores[2] = 72;
scores[3] = 85;
scores[4] = 64;
```

`scores[]`の`[]`に、何番目の配列かをして、`=`で値を代入しています。
注意事項として、配列の一番最初の要素番号は、`0`から始まる事に注意してください。
今回は配列を５つ分用意していますが、配列の最後の要素番号を指定したい場合は、`scores[5]`にするとコンパイルエラーとなります。
配列の要素番号は0から始まっているので、最後の要素番号を指定する場合は、`scores[4]`となります。

これで配列を使わなかった場合は、int型の変数を５つ用意していたのが、int型の配列変数`scores`一つに全ての点数を保持できるようになりました。
5つぐらいなら頑張って変数を作ってもいいと考えてしまうかもしれませんが、配列であれば100でも1000でも一つの配列変数に保持する事が可能です。

### 配列の宣言と初期化、値の代入
​
配列の宣言と初期化、値の代入は同時に行う方法があります。
​
```java
int[] scores = {90, 45, 72, 85, 64};
```

今まで通り`scores`という配列を用意し、`{}`で囲った値を`=`で値を配列に代入します。  
この場合も配列の要素番号は`0`から順番に振り当てられていくので、`scores[0]`には`90`が入ります。  
要素番号を指定せずに0番目から順番に値を代入したい場合はこの方法で行うこともできます。


配列を出力する場合は、

```java
int[] scores = {90, 45, 72, 85, 64};
​
System.out.println(scores[3]);
```

これで、配列変数`scores`の要素番号が`3`の値を出力できます。

配列は繰り返し文と組み合せての使用がよくあります。
次の繰り返し文もしっかりと修得しましょう。

---

## 繰り返し for

for文は、繰り返しの処理です。
2の5乗をfor文無しで書くと、

```java
int result = 1;

result = result * 2;   //１回
result = result * 2;   //２回
result = result * 2;   //３回
result = result * 2;   //４回
result = result * 2;   //５回
​
System.out.print("2の5乗 : ");
System.out.println(result);
```
​
少し面倒ですね。  
for文で書くと同様の処理を何百何千何万回でも処理してくれます。
​
```java
int result = 1;
​
for(int i = 0; i < 5; i++) {
    result = result * 2;
}

System.out.println("2の5乗 : " + result);

```
​
for文はコンピューターの真骨頂といえるかもしれません。人間だと同じ事を何回もしていたら飽きてしまうし、間違えます。プログラムによる処理なら飽きもせずに同じ処理を何万回でもすることができ、間違えることもなく高速です。
​
**for文は、  
for(初期設定; 条件; 継続処理)  
{  
    処理  
}  
と書きます。**    

例でみると初期設定では、for文の中だけで使うint型の変数iを変数宣言して、同時に初期化で`0`を代入しています。  
条件は比較演算子で`i < 5`なので、`i`が`5`未満の間は`true`を返して、`{}`ブロック内の処理を実行します。`i`が`5`以上になると`false`を返して、`for`文を抜けて次の処理にいきます。  
継続処理についてですが、ブロックの処理が一番最後まで実行されたら、継続処理が実行されます。`i++`と書いているので、ブロックの処理が終わるごとで`i`に`1`が加算されます。  
今回は、`i`が`0`から始まって、`i`が`5`未満の間は処理実行と`i`への加算を繰り返して、`i`が`5`になったらfor文の処理を終了します。
処理の中は、何をやっているか考えてみてください。
`result`の初期値は何で、どんな処理が何回実行されて、最後は何が出力されますか？
​
少しだけ改造して下記のように作ると、より汎用的です。
​
```java
int result = 1;
int n = 5;
​
for(int i = 0; i < n; i++) {
    result = result * 2;
}

System.out.println("2の" + n + "乗 : " + result);

```
​
改造前と比べると、変数`n`の初期化の値を変えるだけで`n`乗を自由に変更できます。
​
### 配列とfor文
​
配列とfor文の組み合わせはよく使うのでしっかり修得しましょう。
​
```java
int[] scores = new int[5];
​
scores[0] = 90;
scores[1] = 45;
scores[2] = 72;
scores[3] = 85;
scores[4] = 64;
​
for(int i = 0; i < scores.length; i++) {
    System.out.println(scores[i]);
}
```
​
配列の説明の時は、配列を出力するときに
​
```java
System.out.println(scores[3]);
```
​
と書いて、`scores`の`3`番目の要素番号を指定していました。
今回は、for文で`i`を使って配列の要素番号を指定しています。
`scores.length`は、長さを返してくれるメソッドです。今は詳細な説明をせずに使っていきますが、今回のように`配列.length`と使うことで、配列の要素数を教えてくれます。
`scores.length`で教えてくれる値は、`5`になります。
if文の中の処理実行条件は、`i`が`5`未満であれば実行するとなります。
​
実行されていく順番を追いかけてみましょう。
​
```java
for(int i = 0; i < scores.length; i++) {
    System.out.println(scores[i]);
}
```
​
`i`が`0`で初期化されているので、最初の処理は、
​
```java
System.out.println(scores[0]);
```
​
が実行されます。今回は出力処理(`println`)だけなので、出力処理が終わるとブロックの最後にきて、
​
```java
for(int i = 0; i < scores.length; i++)
```
​
`()`内で三つ目の`i++`が実行されて、`i`の値が`0`から`1`になります。
`i`が`1`なので、`1 < 5(scores.length)`の条件を満たすため、`2`回目の処理を実行します。
​
```java
System.out.println(scores[1]);
```

この要領で`i`の値をインクリメントで加算していき、`scores`配列の各要素を順番に出力します。
`i`が`4`の時、最後の配列要素である`scores[4]`の出力が実行され、`i++`で`i`が`5`になると、`5 < 5` は条件を満たさず`false`となり、for文の処理を終了します。
これで全ての配列要素に対して処理を実行して、次の処理へ移る処理ができるようになりました。

---
### 拡張for文(foreach文)
​
これまで取り扱ってきたfor文とは別に拡張for文(foreach文)があります。  
特定の条件では拡張for文で記述したほうが見やすくなります。
まずはfor文と拡張for文の違いを見ていきます。   
​
```java
int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
​
for(int i = 0; i < numbers.length; i++) {
    int number = nunumbers[i] + 5; // 各要素に+5した値をnumberに代入⇒出力
    System.out.println(number);
}
```
まずはfor文から、このfor文では配列内のすべての値をfor文で取得して出力していますね。  
このように配列内の値をすべて取得したいときに役立つのが拡張for文になります。  
このfor文を拡張for文に直すとこんな感じになります。
​
```java
int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
​
for(int number : numbers) {
    number += 5;
    System.out.println(number);
}
```

かなり見やすくなりましたね。
この拡張for文では配列`scores`の値一つ一つを`score`という変数に代入して出力しています。  
添え字の`i`を用意する必要もなく、`.length`などで配列の要素がいくつあるのか意識する必要がありません。
ただ、普通のfor文のように`[i]`がないので配列の何番目か指定できません。  
また、新たに変数を用意しなくても配列内のすべての値一つ一つに同じ処理をすることもできます。  

現時点ではどこが便利なのかピンと来ないかもしれませんが、  
今後新人研修や現場でListやイテレータを使う際に使い勝手がよいので拡張for文の書き方は覚えておきましょう。

---
